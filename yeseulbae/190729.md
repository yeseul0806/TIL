# 190729 GIT&GITHUB 이고잉 선생님

GIT: INFORMATION MANAGER AND HELL </br>
한달정도 git을 이용해서 매일 해보기

공부 = 나의 문제*상상력 > 공부의 어려움 </br>
4세대는 GIT </br>
잘나가는 이유는 기능이 좋아서. 사용성은 좋진 않아. </br>
git 의 경제적인 원리 위주로 수업.

소프트웨어는 인간이 수동으로 할 수 있는 일만 자동으로 할 수 있다.
먼저 항상 수동으로 해보기.

버전관리 시스템
-> 4세대 GIT </br>
원리 자체는 작고 간단하고 쉽다.

버전을 만든다. 버전을 다룬다. 이게 왜 환상적인지 공감하는 것이 3일간의 과제. </br>
보여주시는 멋진 기능들은 그냥 이런게 있다 정도만으로 알아두라. 

sourcetree 이용해서 깃을 사용할 것임. </br>
깃은 명령어 기반.</br>
후반부로 갈수록 command line으로 할 거임.</br>

바탕화면의 working 폴더가 이제 진행할 프로젝트 폴더.

깃은 하나하나 다 수동으로 해야하지만 각각의 버전을 정교하게 컨트롤해야 하는 것들을 다루기 위해서 그러는 거야.

필요할 때는 .git 폴더 그대로 복사해서 가지고 있으면 돼.

CRUD</br>
CREATE READ UPDATE DELETE </br>
생성   읽기 이 두가지가 젤 중요해. 

사용이 많다.

git 쓰는 이유. 수정하는 것의 버전을 만들기 위해.
파일의 이름을 바꾸지 않고 모든 버전을 보관하는 것.
깃은 어떤 것도 버리거나 지우지 않아.

## sourcetree 
* 파일 드래그 해서 위로 올리기
* 맡애 창에 적은 걸로 git에 그 버전을 커밋한 것. 커밋 버튼
* 밑에 어떤 변경 사항이 있었다고 알려주고 그럴 때마다 저장
* master 을 누르면 버전이 얼마나 생성되어 있는지 볼 수 있다.
* 좀 더 자세하게 다루는 법
* 단위 작업이(주관적) 끝났을 때 버전을 만드는 것이 바람직.
* 깃은 파일의 수정사항을 추적
* work.txt는 버전이 한번이라도 등록이 되었으니까 관리되고 있는것.
* 깃은 모든 것이 수동. 내가 버전 관리하라고 지정하기 전까지 안함. 다 수동이다.
* 여러 파일을 한번에 수정되었을 때 같은 버전으로 포함해서 저장할 수 있다.
* 하나의 버전에 여러개의 파일을 포함시킬 수 있다.
* 여러개의 파일을 수정했을 때 파일을 나눠서 버전 관리 할 수 있다. ex) a,b 는 버전1 c은 버전 2 이렇게
![그림으로](./aa.jpg)
* project folder(stage area(.git(repository)), .working dir(파일을 수정하는 곳)) </br>
(1) working dir을 stage area로 이번의 버전이 될 파일들을 add 한다. </br>
(2) 그 add된 파일을 commit 하면 repository로 넘어간다.


* 녹음 4
* 예전 버전으로 돌아가고 싶을 때는 원하는 버전을 더블클릭해.(또는 checkout) 나의 프로젝트 폴더가 그 버전이 만들어진 때로 이동함. (아직 커밋하지 않은 게 있는 상태면 뒤로 안 돌아가니까 다 커밋한 후에 실행해라.)

* master(가장 최신 버전)으로 돌아가고자 함.
* 오늘의 주인공은 haed
* head가 가리키고 있는 버전으로 변한다.
* 최신 버전으로 가고싶으면 master 클릭
* checkout 과 branches의 master를 누르는건 다르다.
* checkout은 헤드를 옮긴다.
* haed는 master를 통해서 최신 버전을 가리키는 역할을 한다.
* 시간 여행 후에는 항상 master를 가장 최신 버전으로 옮긴 후에 수정해야해.
* 마스터는 내가 만든 마지막 버전이 무엇인지 가리킨다.

* init을 했다.

* discard(폐기) remove(제거)
* 파일을 삭제해도 그게 뜸. 그럼 그 해당 워크를 discard 하면 새로 다시 생김.

![커밋아이디](./rrrr.PNG)
* 커밋 아이디는 유일무일한 식별자.


![녹음 들어봐](./bb.jpg)
녹음 이십분 부터 다시 들어
* 부모를 기억한다.?

* master가 움직였기 때문에 head가 움직이는 것처럼 보인다. master는 나의 마지막 버전을 가리킴 
* head는 나의 워킹 카피가 어느 버전에서 유래했는가를 가리킴.
(워킹카피=워킹디렉토리=파일이 있는 공간)

* checkout은 헤드를 옮긴다.
* 시간여행 끝내고 master를 더블클릭(체크아웃)

* 공덕동 5 녹음 36분부터 다시 듣기

* head가 master를 가리키지 않고 버전을 직접 가리킨다.= haed가 master로부터 떨어졌다.(detached head)
새로운 버전은 헤드가 가리키는 것을 부모로 한다.
* ex) work1에 checkout을 한 상태에서 새로운 것을 커밋하면 새로운 work 5는 work1에서 유래한 상태
이 상태에서 master을 가리키면 work5는 없는 상태가 된다.

* master와 head의 관계 이해하기
* 파일과 변경사항과 버전

녹음 6

버전 : a가 만들어진 시점의 워킹디렉토리의 스냅샷. 버전의 정의 자체는 스냅샷

* 버전 c,d를 지우고 싶다. b로 돌아가서 새출발

* reset(한글버전 초기화)하면 master가 바뀌고 checkout을 하면 head가 바뀐다.
ex) b로 reset하면 c,d는 아무도 안 가리키니까 삭제한 효과가 나는 것이다. 그러면 master도 b를 head도 b를 워킹디렉토리를 가진다.
* checkout은 시간여행 reset은 삭제

* 중요한건 commit이다.

* 파괴적 행동을 하기 전에 저장소 전체를 카피하던가 아니면 commit 아이디를 저장해둔다.

* 버전 만들기, 저장소 만들기, 체크아웃으로 시간여행, 리셋까지만 건전한 거! 이것까지만 확실히 알기

## CLI(COMMAND LINE INTERFACE 검정창), GOI(GRAPHIC USER INTERFACE화면에서 클릭클릭하는거)

* 인터페이스는 조작장치, 핸들

pwd : 현재 내가 어디에 있는가를 볼 수 있음.




